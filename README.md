Motivational Blurb
------------------

One of the prerequisites of writing the (long, convoluted, exquisitely formatted) paper necessary to escape from college with a shiny
new graduate degree is to have some data available upon which to base said paper.  To this end, the PyBrIG toolkit is designed to
gather performance data from bro as it executes against a particular trace.

Note that this github project contains code only to handle the _collection_ of data.  It does not include code to visualize the
results.  For that code (and instructions on its use), please take a look at TODO.

Overview
--------

The Python Bro Information Gatherer (PyBrIG) project aims to automate the process of gathering system information and actually executing
a benchmark on a given system.  It aims to be cross-platform (targeted platforms are OSX 10.8+, FreeBSD 9+, and Linux 3.0+),
simple (a single wrapper script to launch a benchmark), and relatively self-contained.  Additionally, the code in here is intended to be
easily reusable / customizable for anyone interested in extending and / or replicating the benchmark process.

Requirements
------------

Building SIGAR bindings requires autoconf, automake, libtool, pkgconfig, Python headers (e.g. python2.7-devel), gcc, and make.

Building psutil requires a functional gcc toolchain to be present.

Please consult the bro documentation for an up-to-date explanation of what is required to successfully build the project on a given platform.

Executing all utilities (including configure.py) requires Python 2.6+ with a working installation of the 'sh' module
available.  If 'sh' is not present, try:

```
/path/to/pip install sh

Running a Benchmark
-------------------

```bash
# Retrieve the relevant source code for this installation.
git clone https://github.com/cubic1271/pybrig ./pybrig
pushd pybrig
# Download / build dependencies we need to run stuff
# Note: this only needs to be done once
/path/to/python configure.py
export LD_LIBRARY_PATH=/tmp/pybrig/env/lib
# s/X.Y/Python.Version/g
export PYTHONPATH=/tmp/pybrig/env/lib/pythonX.Y/site-packages:/tmp/pybrig/env/lib64/pythonX.Y/site-packages```
export LD_LIBRARY_PATH=/tmp/pybrig/env/lib
# Execute the information gathering script
/path/to/python gather.py
# Execute the benchmark script
/path/to/python benchmark.py

The results of the gather / benchmark scripts are generated in JSON format.  These results can be reviewed and e.g.
uploaded to something like ElasticSearch.

Privacy
-------

While the majority of the data included in the results of these benchmarks cannot be linked to a specific domain / machine,
there is *some* data that may be used in this fashion.  Specifically, the following information is included in the results
of a benchmark:

* Host interfaces (IPv4, IPv6, and MAC addresses for all interfaces)
* Hostnames
* Some trace statistics
* Partitions currently available on the machine (along with their filesystem type)

To help address this issue, a file is included here called 'privacy.conf'.  This file lists a number of regex-based filters
that are applied (as best as these utilities are able) to data generated by the tools that are run as part of the benchmark.

_NOTE_: Please review *all* configuration / benchmark results before uploading them.  privacy.conf is offered as a
convenience _only_, not as any kind of guarantee.

This file consists of a number of sections that appear as follows:

```
[X.include]
.*:.*
[X.exclude]
.*:.*

Each section of the above file [X.include, X.exclude] is defined to be a list of _Allow / Deny Rules_ that govern which pieces
of information are included in the output.  The portion on the left side of the ':' refers to the 'name' of the entry, and
the portion on the right side of the ':' is a regex that is applied to the 'value' of the entry.

Rules are applied in order, and _the last rule to match the name and / or value_ wins.  In the event an include and exclude
rule both match a particular piece of output, the _exclude_ rule takes precedence.  If _neither_ an include nor an exclude
rule matches an item, the item is _excluded_.

As an example, say we only wanted to include entries from sysctl that had 'ip' somewhere in the name.  Our rule set would be:

```
[sysctl.include]
.*ip.*:.*
[sysctl.exclude]

Alternatively, say we wanted to include entries from sysctl that had a value that began with '1'.  Our rule set would be:

```
[sysctl.include]
.*:1.*
[sysctl.exclude]

If we wanted entries from the 'ip' section of sysctl that had a value that started with '1', these rules could be combined:

```
[sysctl.include]
.*ip.*:1.*

Note that the 'interfaces' section is a special one, and consists of the following keys:

* 'address': the IPv4 address of the interface
* 'address6': the IPv6 address of the interface
* 'hwaddr': the MAC address of the interface
* 'name': the name of the interface (e.g. 'eth0', 'en0')

Note that the above corresponds with the output of the 'interfaces' information as displayed by gather.py

Contributing
------------

TODO
